# -*- coding: utf-8 -*-
"""Projectiles v3 session.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iX6lIWaYsr9prvy39KghrwMQVnqt881F

# Simulating Projectile motion (version 3 - session)

#### Ver 1:
- The aim of the first version is to have a working implementation of the _Euler method_ for the motion of a projectile.
- the _input parameters_ are set in the code and the _output_ yields the final position and velocity of the projectile
- In the _evaluation_ we simply print out the error of the values obtained by the _Euler method_ when compared to the ones obtained using _SUVAT_

#### Ver 2:
- The aim of this second version is to improve the _output_ and _evaluation_ by saving and comparing the postion and velocity for each time step and plotting the data.

#### Ver 3:
- Add animated graphs using `matplotlib`
---
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing packages
import numpy as np
import matplotlib.pyplot as plt

# Method for animating plots
from matplotlib.animation import FuncAnimation

# For jupyter notebooks: to display animations inline
from IPython.display import HTML


### Input

# initial position and velocity of the point particle
pos_init = np.array([.0, .0])
vel_init = np.array([10.0, 20.0])

# Set the acceleration g due to gravity
g = np.array([.0, -9.81])

# Set the number N of time steps 
N = 100
# Set a final time 
t_final = 4

dt = t_final/N


### Main

# Implementing the Euler method
# Set the intial values for position and velocity
pos = pos_init
vel = vel_init

# List for saving the position for each time step for plotting and evaluation
trajectory = [pos]

# List for saving the velocity for each time step for plotting and evaluation 
vel_data = [vel]

# Calculate the new position and velocity for each time step and save them in the respective lists
for i in range(N):
    pos = pos + vel*dt
    vel = vel + g*dt
    trajectory.append(pos)
    vel_data.append(vel)


### Output

# Output: plot the trajectory of the projectile

# we 'unzip' the list of position vectors into two tuples of x- and y-components and plot the data
x,y = zip(*trajectory)

plt.plot(x, y)
plt.xlabel("$x$-coordinate")
plt.ylabel("$y$-coordinate")
plt.show()

##### Animation of the trajectory

# Setting up the plotting figure
anim_fig, anim_ax = plt.subplots()

# Saving the line2D object we will use for plots
line, = plt.plot([], [])

# Setting scale and range of coordinate axis. 
# To do: determine from inputs automatically
anim_ax.set_xlim(0, 40)
anim_ax.set_ylim(0, 25)

# Called for each frame to plot the data until the index `frame`
def update(frame):
    line.set_data(x[:frame] , y[:frame])
    return line,

# create the animation object using the figure `anim_fig` by calling the function update for each value in the list `frame`
# To do: Improve the code to only use a sensible number of frames
# To do: Improve the code so that animation time corresponds to simulated time
ani = FuncAnimation(anim_fig, update, frames=range(N),
                     blit=True)

HTML(ani.to_html5_video())


# Plotting the v_x and v_y components over time

# We create a figure with two plots next to each other
# fig is the figure object, ax is the axes object which we use to plot in
fig, ax = plt.subplots(1,2, figsize= (15,4)) 

# we 'unzip' the list of velocity vectors into two tuples of v_x- and v_y-components
vx, vy = zip(*vel_data)

# we create the time data using linspace (look up what it does!)
t_data = np.linspace(0, t_final, N+1)

ax[0].set_xlabel("time $t$", fontsize=12)
ax[0].set_ylabel("$v_x$", fontsize=14)
ax[0].plot(t_data, vx)

ax[1].set_xlabel("time $t$", fontsize=12)
ax[1].set_ylabel("$v_y$", fontsize=14)
ax[1].plot(t_data, vy)

# plot the results
plt.show()


### Evaluation

#### Position

# Compare the trajectories calculated with Euler vs SUVAT

# Calculate the trajectory using SUVAT and a list comprehension
trajectory_analytic = [pos_init + vel_init * (k*dt) + 1/2 * g * (k*dt)**2 for k in range(N+1)]

# Use tuple unpacking to obtain tuples of x- and y-coordinates of the list of position vectors
x_analytic, y_analytic = zip(*trajectory_analytic) 

# Plot both trajectories in one graph
plt.plot(x,y, label = 'Euler')
plt.plot(x_analytic, y_analytic, label = 'Analytic')

# Show the legend and the graph
plt.legend()
plt.show()


# Calculate the differences in x and y values for the analytic and the Euler data

# As both are tuples and thus immutable we need to convert them to numpy arrays first, 
# if we wish to take the componentwise difference without using a `for` loop
x_err = np.array(x) - np.array(x_analytic)
y_err = np.array(y) - np.array(y_analytic)

# We create a figure with two plots next to each other
# fig is the figure object, ax is the axes object which we use to plot in
fig, ax = plt.subplots(1,2, figsize= (15,4)) 

# Using f-strings allows us to include the value of variables like `dt` in the string of a label. 
# This way we don't have to change it manually in the string when we change the values in the input section.
# An f-string is indicated by the leading `f` and variables are included using curly brackets
ax[0].set_xlabel(f"number of time steps for $\Delta t$ = {dt}s", fontsize=14)
ax[0].set_ylabel("$\Delta x$", fontsize=14)
ax[0].plot(x_err)

ax[1].set_xlabel(f"number of time steps for $\Delta t$ = {dt}s", fontsize=14)
ax[1].set_ylabel("$\Delta y$", fontsize=14)
ax[1].plot(y_err)

# plot the results
plt.show()


#### Velocity

# Compare the velocities calculated with Euler vs SUVAT

# Calculate the velocities for each time step using SUVAT and a list comprehension
vel_analytic = [vel_init  +  g * (k*dt) for k in range(N+1)]

# Use tuple unpacking to obtain tuples of x- and y-coordinates of the list of velocity vectors
vx_analytic, vy_analytic = zip(*vel_analytic) 
 
# We calculate the componentwise differences using vectors instead of a `for` loop
vx_err = np.array(vx) - np.array(vx_analytic)
vy_err = np.array(vy) - np.array(vy_analytic)

# We create a figure with two plots next to each other
# fig is the figure object, ax is the axes object which we use to plot in
fig, ax = plt.subplots(1,2, figsize= (15,4)) 

# Using f-strings we include the value of variable `dt` in the string of a label. 
ax[0].set_xlabel(f"number of time steps for $\Delta t$ = {dt}s", fontsize=14)
ax[0].set_ylabel("$\Delta v_x$", fontsize=14)
ax[0].plot(vx_err)

ax[1].set_xlabel(f"number of time steps for $\Delta t$ = {dt}s", fontsize=14)
ax[1].set_ylabel("$\Delta v_y$", fontsize=14)
ax[1].plot(vy_err)

plt.show()
